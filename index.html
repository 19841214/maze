<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vocab Quest 3D - Ëã±ÈõÑÊ¶úÁâà</title>
    <style>
        :root {
            --primary: #5865f2;
            --danger: #ff4757;
            --success: #00b894;
            --warning: #fdcb6e;
            --gold: #ffeaa7;
            --bg: #020205;
            --panel-bg: rgba(15, 15, 25, 0.95);
        }
        body { margin: 0; background: var(--bg); color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; touch-action: none; user-select: none; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: var(--panel-bg); padding: 20px; border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(12px);
            pointer-events: none; width: 260px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        #hud h1 { margin: 0; font-size: 20px; letter-spacing: 1px; color: #fff; text-shadow: 0 0 10px var(--primary); }
        #hud p { margin: 8px 0 0; font-size: 13px; opacity: 0.9; }
        .progress-container { margin-top: 15px; }
        .progress-bar { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--success)); transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 0 10px var(--success); }

        /* Login Overlay */
        #login-overlay {
            position: fixed; inset: 0; background: rgba(2, 2, 5, 0.95); z-index: 20000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(10px);
        }
        .login-box {
            background: #1e1e2f; padding: 40px; border-radius: 24px; border: 2px solid var(--primary);
            text-align: center; width: 90%; max-width: 400px; box-shadow: 0 0 50px rgba(88, 101, 242, 0.3);
        }
        .login-input {
            width: 80%; padding: 15px; border-radius: 12px; border: 1px solid #444;
            background: #2b2b3d; color: white; font-size: 18px; margin-bottom: 20px; text-align: center; outline: none;
        }
        .login-btn {
            padding: 15px 40px; background: var(--primary); color: white; border: none; border-radius: 12px;
            font-size: 18px; cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        .login-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px var(--primary); }

        /* Win Screen (Epic Style) */
        #win-screen {
            position: fixed; inset: 0; background: rgba(5, 5, 10, 0.95); z-index: 10000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; backdrop-filter: blur(15px);
        }
        .win-title {
            font-size: 4rem; color: var(--success); text-shadow: 0 0 30px var(--success);
            margin-bottom: 10px; animation: slideDown 0.8s ease-out;
        }
        .win-stats-card {
            background: rgba(255, 255, 255, 0.05); padding: 30px; border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1); width: 90%; max-width: 500px;
            margin: 20px 0; animation: fadeIn 1s ease-out 0.5s backwards;
        }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 18px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .mvp-list { margin-top: 20px; text-align: left; }
        .mvp-item { color: var(--gold); font-weight: bold; margin: 5px 0; font-size: 16px; display: flex; align-items: center; gap: 10px; }
        .rank-badge { background: var(--gold); color: black; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }

        @keyframes slideDown { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Crosshair & HP */
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; flex-direction: column; align-items: center; pointer-events: none;
        }
        #wall-hp-bar {
            width: 140px; height: 12px; background: rgba(0,0,0,0.8); border: 2px solid #fff; border-radius: 8px; 
            margin-top: 15px; overflow: hidden; display: none; box-shadow: 0 0 10px var(--warning);
        }
        #wall-hp-fill { width: 0%; height: 100%; background: var(--warning); transition: width 0.2s; }
        #wall-hp-text { font-size: 16px; font-weight: bold; text-shadow: 1px 1px 3px black; margin-top: 5px; display: none; color: var(--warning); }

        /* Controls */
        #mobile-controls {
            position: absolute; bottom: 30px; right: 30px; z-index: 20;
            display: none; flex-direction: column; align-items: center; gap: 10px;
        }
        .control-row { display: flex; gap: 15px; }
        .dpad-btn {
            width: 65px; height: 65px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            color: white; font-size: 24px; display: flex; align-items: center; justify-content: center;
            touch-action: manipulation; backdrop-filter: blur(4px); transition: background 0.1s;
        }
        .dpad-btn:active { background: var(--primary); border-color: var(--primary); }
        @media (max-width: 1024px) { #mobile-controls { display: flex; } }

        /* Quiz */
        #quiz-overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.95);
            display: none; align-items: center; justify-content: center; z-index: 1000;
            backdrop-filter: blur(10px);
        }
        .quiz-card {
            background: #11111d; width: 90%; max-width: 600px; padding: 40px;
            border-radius: 24px; border: 2px solid var(--primary); text-align: center;
            box-shadow: 0 0 60px rgba(88, 101, 242, 0.3); position: relative; overflow: hidden;
        }
        .monster-mode { border-color: var(--danger) !important; box-shadow: 0 0 60px rgba(255, 71, 87, 0.4) !important; }
        .question { font-size: 26px; font-weight: 700; margin-bottom: 30px; color: #fff; line-height: 1.4; min-height: 60px; display: flex; align-items: center; justify-content: center; }
        .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        button {
            padding: 18px; font-size: 18px; border: none; border-radius: 12px;
            background: rgba(255, 255, 255, 0.08); color: #fff; cursor: pointer;
            transition: all 0.2s; border: 1px solid rgba(255, 255, 255, 0.1); font-weight: 600;
        }
        button:hover { background: var(--primary); transform: scale(1.02); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        /* Feedback */
        #feedback-overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.95);
            display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 20;
        }
        #feedback-icon { font-size: 70px; margin-bottom: 20px; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }
        #feedback-text { font-size: 28px; font-weight: bold; padding: 0 20px; }
        #feedback-sub { font-size: 18px; color: #ccc; margin-top: 15px; max-width: 80%; line-height: 1.4; }

        #monster-status {
            position: absolute; top: 20px; right: 20px; padding: 10px 20px;
            background: rgba(0,0,0,0.7); border-radius: 20px; border: 1px solid var(--danger); color: var(--danger);
            font-size: 16px; font-weight: bold; display: none; box-shadow: 0 0 15px rgba(255, 71, 87, 0.3);
        }

        #loading { position: fixed; inset: 0; background: var(--bg); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .spinner { width: 50px; height: 50px; border: 5px solid rgba(88,101,242,0.2); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s infinite cubic-bezier(0.5, 0.1, 0.4, 0.9); }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        #message-box {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            padding: 15px 35px; border-radius: 100px; background: var(--panel-bg);
            border: 1px solid var(--primary); font-weight: bold; display: none; z-index: 100;
            backdrop-filter: blur(8px); animation: fadeIn 0.3s;
        }
    </style>
</head>
<body>

<div id="loading">
    <div class="spinner"></div>
    <p style="margin-top: 20px; letter-spacing: 2px; font-size: 14px; opacity: 0.7;">Ê≠£Âú®ÂêåÊ≠•ÂúòÈöäÂú∞Áâ¢...</p>
</div>

<div id="login-overlay" style="display: none;">
    <div class="login-box">
        <h2>Ëº∏ÂÖ•ÊÇ®ÁöÑÂßìÂêç</h2>
        <input type="text" id="player-name-input" class="login-input" placeholder="‰æãÂ¶Ç: Kevin" maxlength="10">
        <button class="login-btn" onclick="submitName()">ÈñãÂßãÊé¢Èö™</button>
    </div>
</div>

<div id="win-screen">
    <div class="win-title">üèÜ ‰ªªÂãôÈÅîÊàêÔºÅ</div>
    <div class="win-stats-card">
        <div class="stat-row">
            <span>ÊÇ®ÁöÑË≤¢Áçª (My Score):</span>
            <span id="my-final-score" style="color: var(--success); font-weight: bold;">0</span>
        </div>
        <div class="stat-row">
            <span>ÂúòÈöäÁ∏ΩÂàÜ (Team Total):</span>
            <span id="team-final-score">0</span>
        </div>
        
        <div class="mvp-list">
            <div style="font-size: 14px; color: #aaa; margin-bottom: 10px;">üëë Ê¶ÆË≠ΩËã±ÈõÑÊ¶ú (Top 3 MVPs)</div>
            <div id="mvp-container">ËºâÂÖ•‰∏≠...</div>
        </div>
    </div>
    <button onclick="location.reload()" class="login-btn" style="background: var(--success);">ÂÜçÊ¨°ÊåëÊà∞</button>
</div>

<div id="message-box"></div>

<div id="hud">
    <h1>VOCAB QUEST</h1>
    <p id="player-count">‚óè ÈÄ£Á∑öÁãÄÊÖãÊ™¢Êü•‰∏≠...</p>
    <div class="progress-container">
        <p id="stats" style="margin-bottom: 5px;">ÂúòÈöäÁ†¥ÁâÜÁ∏ΩÊï∏: 0</p>
        <div class="progress-bar"><div id="progress-fill"></div></div>
    </div>
    <p id="goal-info" style="color: var(--warning); font-size: 11px; margin-top: 8px;">‚óà ÈúÄÁ¥ØÁ©çË∂≥Â§†ÂàÜÊï∏ÈñãÂïüÂÇ≥ÈÄÅÈñÄ</p>
</div>

<!-- Mobile Controls -->
<div id="mobile-controls">
    <div class="control-row">
        <div class="dpad-btn" id="btn-up">‚ñ≤</div>
    </div>
    <div class="control-row">
        <div class="dpad-btn" id="btn-left">‚óÄ</div>
        <div class="dpad-btn" id="btn-down">‚ñº</div>
        <div class="dpad-btn" id="btn-right">‚ñ∂</div>
    </div>
</div>

<div id="monster-status">üòà ÊÄ™Áâ©ÈáçÁîüÂÄíÊï∏: <span id="cooldown-timer">10</span>s</div>

<div id="crosshair">
    <div style="width: 4px; height: 4px; background: white; border-radius: 50%; box-shadow: 0 0 4px white;"></div>
    <div id="wall-hp-bar"><div id="wall-hp-fill"></div></div>
    <div id="wall-hp-text">WALL HP: 10/10</div>
</div>

<div id="user-id-display" style="position: absolute; bottom: 15px; left: 15px; font-size: 10px; opacity: 0.3;"></div>

<div id="quiz-overlay">
    <div class="quiz-card" id="quiz-card">
        <div id="quiz-msg" style="color: var(--danger); margin-bottom: 15px; font-weight: bold; letter-spacing: 1px;">[ SYSTEM LOCKED ]</div>
        <div id="monster-combo" style="display: none; color: var(--warning); margin-bottom: 15px; font-size: 18px;">ÈÄ£Á∫åÊ≠£Á¢∫: 0 / 3</div>
        <div class="question" id="q-text">Loading...</div>
        <div class="options-grid" id="q-options"></div>
        
        <!-- Feedback Layer -->
        <div id="feedback-overlay">
            <div id="feedback-icon">‚≠ï</div>
            <div id="feedback-text">Correct!</div>
            <div id="feedback-sub"></div>
        </div>
    </div>
</div>

<canvas id="canvas"></canvas>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, runTransaction, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCOI2MloQp3rLf2T90vxep9b4zwKsUWEIs",
  authDomain: "workshop-test-98617.firebaseapp.com",
  databaseURL: "https://workshop-test-98617-default-rtdb.firebaseio.com",
  projectId: "workshop-test-98617",
  storageBucket: "workshop-test-98617.firebasestorage.app",
  messagingSenderId: "636905955796",
  appId: "1:636905955796:web:a01740ce01d98447d4b641"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'vocab-v3-coop';

const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRUrIh3_ELuEAFnI6VRdWWI8AnmkJKh_bplW5PTw3PgQHAyyhXgUZokKOLC0eRcBv9T-XEPti1OlEHI/pub?gid=0&single=true&output=csv";

const DEFAULT_QUESTIONS = [
    { q: "Past Participle of 'Eat'", a: "Eaten", b: ["Ate", "Eating", "Eats"] },
    { q: "She has ___ home.", a: "gone", b: ["go", "went", "going"] },
    { q: "Adjective?", a: "Beautiful", b: ["Beauty", "Beautifully", "Beautify"] },
    { q: "Synonym of 'Happy'", a: "Joyful", b: ["Sad", "Angry", "Tired"] },
    { q: "Antonym of 'Big'", a: "Small", b: ["Huge", "Large", "Giant"] }
];

let questionBank = [];
let otherPlayers = {};

let worldMap = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,2,0,2,0,0,0,2,0,0,2,0,3,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,2,0,0,0,2,0,0,0,2,0,0,0,2,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,2,0,0,2,0,0,2,0,0,2,0,0,2,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,2,0,0,0,2,0,2,0,2,0,0,0,2,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,2,0,0,2,0,0,0,0,0,2,0,0,2,1],
    [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1],
    [1,2,0,0,0,2,0,2,0,2,0,0,0,2,1],
    [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,2,0,0,0,0,0,2,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const WALL_MAX_HP = 10;
let wallHitsData = {};

// Player data now tracks personal score
const player = { x: 1.5, y: 13.5, dir: -Math.PI/2, v: 0, w: 0, fov: Math.PI / 3, totalSolved: 0, personalScore: 0, name: "Player" };
const monster = { x: 13.5, y: 13.5, speed: 0.012, cooldownUntil: 0 };
const keys = {};
let userId = "", isMonsterQuiz = false, monsterCombo = 0, isGameOver = false;
let isOfflineMode = false;

window.submitName = () => {
    const input = document.getElementById('player-name-input');
    const name = input.value.trim();
    if (name) {
        player.name = name;
        document.getElementById('login-overlay').style.display = 'none';
        startGame();
    } else {
        alert("Ë´ãËº∏ÂÖ•ÂßìÂêçÔºÅ");
    }
};

function parseCSVRow(row) {
    let result = [];
    let current = '';
    let inQuote = false;
    for (let i = 0; i < row.length; i++) {
        let char = row[i];
        if (char === '"') {
            if (inQuote && row[i + 1] === '"') { 
                current += '"'; i++;
            } else { inQuote = !inQuote; }
        } else if (char === ',' && !inQuote) {
            result.push(current.trim()); current = '';
        } else { current += char; }
    }
    result.push(current.trim());
    return result;
}

const startGame = () => {
    spawnPlayerRandomly();
    document.getElementById('loading').style.opacity = 0;
    setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
    setupMobileControls();
    gameLoop();
};

const spawnPlayerRandomly = () => {
    let validSpots = [];
    for(let y=1; y<worldMap.length-1; y++) {
        for(let x=1; x<worldMap[0].length-1; x++) {
            if(worldMap[y][x] === 0 && (x < 12 || y < 12)) {
                validSpots.push({x: x + 0.5, y: y + 0.5});
            }
        }
    }
    if(validSpots.length > 0) {
        const spot = validSpots[Math.floor(Math.random() * validSpots.length)];
        player.x = spot.x; player.y = spot.y;
    }
};

const setupMobileControls = () => {
    const bind = (id, k) => {
        const el = document.getElementById(id);
        const on = (e) => { e.preventDefault(); keys[k] = true; };
        const off = (e) => { e.preventDefault(); keys[k] = false; };
        el.addEventListener('touchstart', on); el.addEventListener('touchend', off);
        el.addEventListener('mousedown', on); el.addEventListener('mouseup', off);
    };
    bind('btn-up', 'arrowup'); bind('btn-down', 'arrowdown');
    bind('btn-left', 'arrowleft'); bind('btn-right', 'arrowright');
};

const initSystem = async () => {
    try {
        const res = await fetch(SHEET_URL);
        const csv = await res.text();
        questionBank = csv.split(/\r?\n/).slice(1).map(line => {
            const cols = parseCSVRow(line);
            if (cols.length < 5) return null;
            return { q: cols[0], a: cols[1], b: [cols[2], cols[3], cols[4]] };
        }).filter(q => q && q.q);
    } catch(e) { 
        questionBank = DEFAULT_QUESTIONS;
    }

    try { await signInAnonymously(auth); } catch (e) { 
        isOfflineMode = true; 
        document.getElementById('loading').style.display = 'none';
        document.getElementById('login-overlay').style.display = 'flex';
        return; 
    }

    onAuthStateChanged(auth, (user) => {
        if (user) {
            userId = user.uid;
            
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'players'), (snap) => {
                snap.docChanges().forEach(c => {
                    if (c.type === "removed") delete otherPlayers[c.doc.id];
                    else if (c.doc.id !== userId) otherPlayers[c.doc.id] = c.doc.data();
                });
                document.getElementById('player-count').innerText = `‚óè Âú®Á∑öÊé¢Èö™ÂÆ∂: ${Object.keys(otherPlayers).length + 1}`;
            });

            onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'worldState', 'global'), (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    player.totalSolved = data.totalSolved || 0;
                    wallHitsData = data.wallHits || {}; 
                    for(let key in wallHitsData) {
                        const [wy, wx] = key.split(',').map(Number);
                        if (wallHitsData[key] >= WALL_MAX_HP && worldMap[wy][wx] === 2) worldMap[wy][wx] = 0;
                    }
                    updateStats();
                }
            });

            setInterval(syncMyPosition, 100);
            document.getElementById('loading').style.display = 'none';
            document.getElementById('login-overlay').style.display = 'flex';
        }
    });
};

async function syncMyPosition() {
    if (!userId || isGameOver || isOfflineMode) return;
    try { 
        await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'players', userId), { 
            x: player.x, y: player.y, dir: player.dir, 
            name: player.name, score: player.personalScore, // ÂêåÊ≠•ÂÄã‰∫∫ÂàÜÊï∏
            time: Date.now() 
        }, { merge: true }); 
    } catch(e) {}
}

async function hitWall(y, x) {
    if (isOfflineMode) {
        const key = `${y},${x}`;
        wallHitsData[key] = (wallHitsData[key] || 0) + 1;
        player.totalSolved++;
        if (wallHitsData[key] >= WALL_MAX_HP) worldMap[y][x] = 0;
        updateStats();
        return;
    }

    const worldRef = doc(db, 'artifacts', appId, 'public', 'data', 'worldState', 'global');
    const key = `${y},${x}`;
    
    try {
        await runTransaction(db, async (transaction) => {
            const sfDoc = await transaction.get(worldRef);
            if (!sfDoc.exists()) {
                transaction.set(worldRef, { wallHits: { [key]: 1 }, totalSolved: 1 });
            } else {
                const data = sfDoc.data();
                const hits = data.wallHits || {};
                hits[key] = (hits[key] || 0) + 1;
                transaction.update(worldRef, { wallHits: hits, totalSolved: (data.totalSolved || 0) + 1 });
            }
        });
    } catch (e) { console.error("Hit Wall Error", e); }
}

function updateStats() {
    const req = 50; 
    const progress = Math.min(100, (player.totalSolved / req) * 100);
    document.getElementById('stats').innerText = `ÂúòÈöäÁ†¥ÁâÜÁ∏ΩÊï∏: ${player.totalSolved}`;
    document.getElementById('progress-fill').style.width = `${progress}%`;
    if (progress >= 100) {
        document.getElementById('goal-info').innerText = "‚óà ÂÇ≥ÈÄÅÈñÄËÉΩÈáèÂ∑≤ÂÖÖÊªøÔºÅ";
        document.getElementById('goal-info').style.color = "var(--success)";
    }
}

// --- ÈÅäÊà≤ÈÇèËºØ ---
function showMessage(text, color = "var(--primary)") {
    const box = document.getElementById('message-box');
    box.innerText = text; box.style.borderColor = color; box.style.display = 'block';
    setTimeout(() => box.style.display = 'none', 3000);
}

// Á≤íÂ≠êÁâπÊïà
let confettiParticles = [];
function createConfetti() {
    for (let i = 0; i < 150; i++) {
        confettiParticles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height - canvas.height,
            color: `hsl(${Math.random()*360}, 100%, 50%)`,
            size: Math.random() * 8 + 4,
            speed: Math.random() * 5 + 2,
            drift: Math.random() * 2 - 1
        });
    }
}
function drawConfetti() {
    confettiParticles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        p.y += p.speed;
        p.x += p.drift;
        if (p.y > canvas.height) confettiParticles.splice(i, 1);
    });
    if (confettiParticles.length < 100 && isGameOver) createConfetti();
}

function gameLoop() {
    if (isGameOver) {
        // Âú®ËÉåÊôØÁπºÁ∫åÁï´ confetti
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        drawConfetti();
        requestAnimationFrame(gameLoop);
        return;
    }
    updateEntities();
    render();
    requestAnimationFrame(gameLoop);
}

let facingWall = null; 

function updateEntities() {
    if (document.getElementById('quiz-overlay').style.display === 'flex') return;
    
    const up = keys['w'] || keys['arrowup'];
    const down = keys['s'] || keys['arrowdown'];
    const left = keys['a'] || keys['arrowleft'];
    const right = keys['d'] || keys['arrowright'];

    if (up) player.v = 0.06; else if (down) player.v = -0.06; else player.v *= 0.8;
    if (left) player.w = -0.05; else if (right) player.w = 0.05; else player.w *= 0.8;
    player.dir += player.w;
    
    const nx = player.x + Math.cos(player.dir) * player.v, ny = player.y + Math.sin(player.dir) * player.v;
    const cell = worldMap[Math.floor(ny)] ? worldMap[Math.floor(ny)][Math.floor(nx)] : 1;
    
    const rayDist = 1.5;
    const fx = player.x + Math.cos(player.dir) * rayDist;
    const fy = player.y + Math.sin(player.dir) * rayDist;
    const fCell = worldMap[Math.floor(fy)] ? worldMap[Math.floor(fy)][Math.floor(fx)] : 0;
    
    const hpBar = document.getElementById('wall-hp-bar');
    const hpText = document.getElementById('wall-hp-text');
    
    if (fCell === 2) {
        facingWall = { x: Math.floor(fx), y: Math.floor(fy) };
        const key = `${facingWall.y},${facingWall.x}`;
        const hits = wallHitsData[key] || 0;
        const hp = Math.max(0, WALL_MAX_HP - hits);
        hpBar.style.display = 'block';
        hpText.style.display = 'block';
        document.getElementById('wall-hp-fill').style.width = `${(hp/WALL_MAX_HP)*100}%`;
        hpText.innerText = `WALL HP: ${hp}/${WALL_MAX_HP}`;
    } else {
        facingWall = null;
        hpBar.style.display = 'none';
        hpText.style.display = 'none';
    }

    if (cell === 0) { player.x = nx; player.y = ny; }
    else if (cell === 2) triggerQuiz(Math.floor(nx), Math.floor(ny));
    else if (cell === 3) {
        if (player.totalSolved >= 50) { winGame(); }
        else { showMessage("ÂàÜÊï∏‰∏çË∂≥ÔºÅÂúòÈöäÈúÄÊõ¥Â§öÂêà‰Ωú„ÄÇ", "var(--warning)"); player.v = -0.2; }
    }

    if (monster.cooldownUntil > Date.now()) {
        document.getElementById('monster-status').style.display = 'block';
        document.getElementById('cooldown-timer').innerText = Math.ceil((monster.cooldownUntil - Date.now())/1000);
        monster.x = 1000; 
    } else {
        document.getElementById('monster-status').style.display = 'none';
        if (monster.x === 1000) { monster.x = 13.5; monster.y = 13.5; }
        const dx = player.x - monster.x, dy = player.y - monster.y;
        if (Math.sqrt(dx*dx + dy*dy) < 0.6) { isMonsterQuiz = true; monsterCombo = 0; triggerQuiz(); }
        monster.x += (dx/Math.sqrt(dx*dx + dy*dy)) * monster.speed; 
        monster.y += (dy/Math.sqrt(dx*dx + dy*dy)) * monster.speed;
    }
}

// Áç≤ÂãùÈÇèËºØ
async function winGame() {
    isGameOver = true;
    document.getElementById('win-screen').style.display = 'flex';
    document.getElementById('my-final-score').innerText = player.personalScore;
    document.getElementById('team-final-score').innerText = player.totalSolved;
    createConfetti();

    // Áç≤Âèñ MVP
    let allPlayers = [{ name: player.name, score: player.personalScore }];
    for (let id in otherPlayers) {
        if(otherPlayers[id].score !== undefined) {
            allPlayers.push({ name: otherPlayers[id].name, score: otherPlayers[id].score });
        }
    }
    allPlayers.sort((a,b) => b.score - a.score);
    
    const mvpContainer = document.getElementById('mvp-container');
    mvpContainer.innerHTML = '';
    allPlayers.slice(0, 3).forEach((p, i) => {
        mvpContainer.innerHTML += `
            <div class="mvp-item">
                <div class="rank-badge">${i+1}</div>
                <span>${p.name}</span>
                <span style="margin-left:auto; color: white;">${p.score} pt</span>
            </div>
        `;
    });
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function render() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const w = canvas.width, h = canvas.height;
    
    const sky = ctx.createLinearGradient(0,0,0,h/2); sky.addColorStop(0,'#050510'); sky.addColorStop(1,'#222');
    ctx.fillStyle = sky; ctx.fillRect(0,0,w,h/2);
    const floor = ctx.createLinearGradient(0,h/2,0,h); floor.addColorStop(0,'#1a1a1a'); floor.addColorStop(1,'#000');
    ctx.fillStyle = floor; ctx.fillRect(0,h/2,w,h/2);

    const zBuffer = new Array(w).fill(Infinity);
    
    for (let i = 0; i < w; i++) {
        const rayAngle = (player.dir - player.fov/2) + (i/w)*player.fov;
        let d = 0, hit = 0, x = player.x, y = player.y, side = 0;
        const sx = Math.cos(rayAngle)*0.01, sy = Math.sin(rayAngle)*0.01;

        while (hit === 0 && d < 14) {
            x += sx; d += 0.01; side = 0;
            if (worldMap[Math.floor(y)][Math.floor(x)] > 0) { hit = worldMap[Math.floor(y)][Math.floor(x)]; break; }
            y += sy; side = 1;
            if (worldMap[Math.floor(y)][Math.floor(x)] > 0) { hit = worldMap[Math.floor(y)][Math.floor(x)]; break; }
        }
        
        const realD = d * Math.cos(rayAngle - player.dir);
        zBuffer[i] = realD;
        const wh = h / realD;
        
        let color = '#444';
        if (hit === 2) { 
            const key = `${Math.floor(y)},${Math.floor(x)}`;
            const hits = wallHitsData[key] || 0;
            const hpRatio = Math.max(0, (WALL_MAX_HP - hits) / WALL_MAX_HP);
            color = `hsl(${hpRatio * 120}, 60%, ${20 + hpRatio * 30}%)`; 
        } else if (hit === 3) color = '#2ed573';
        
        if (side === 1) ctx.globalAlpha = 0.7;
        ctx.fillStyle = color; ctx.fillRect(i, (h-wh)/2, 1, wh);
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = `rgba(0,0,0,${Math.min(1, realD/12)})`; ctx.fillRect(i, (h-wh)/2, 1, wh);
    }

    const sprites = [{ x: monster.x, y: monster.y, type: 'monster' }, { x: 13.5, y: 1.5, type: 'goal' }];
    Object.values(otherPlayers).forEach(p => sprites.push({ ...p, type: 'player' }));
    sprites.sort((a,b) => {
        return (Math.pow(player.x-b.x,2)+Math.pow(player.y-b.y,2)) - (Math.pow(player.x-a.x,2)+Math.pow(player.y-a.y,2));
    });

    sprites.forEach(s => {
        const dx = s.x - player.x, dy = s.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let ang = Math.atan2(dy, dx) - player.dir;
        while (ang < -Math.PI) ang += Math.PI * 2;
        while (ang > Math.PI) ang -= Math.PI * 2;
        
        if (Math.abs(ang) < player.fov) {
            const sx = (0.5 * (ang / (player.fov / 2)) + 0.5) * w;
            const sh = h / dist;
            if (dist < zBuffer[Math.floor(sx)]) {
                if (s.type === 'monster') {
                    ctx.fillStyle = `rgba(255, 0, 0, ${0.7 + Math.sin(Date.now()/200)*0.3})`;
                    ctx.fillRect(sx-sh/4, (h-sh)/2, sh/2, sh);
                } else if (s.type === 'player') {
                    ctx.fillStyle = 'cyan'; ctx.fillRect(sx-sh/6, h/2, sh/3, sh/2);
                    if (s.name) {
                        ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(s.name, sx, h/2 - sh/2 - 5);
                    }
                } else {
                    ctx.fillStyle = '#2ed573'; ctx.beginPath(); ctx.arc(sx, h/2, sh/4, 0, Math.PI*2); ctx.fill();
                }
            }
        }
    });
    
    drawMinimap(w);
}

function drawMinimap(w) {
    const s = 8, p = 10, mw = 15*s, mh = 15*s;
    const ox = w - mw - p, oy = p;
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(ox, oy, mw, mh);
    
    for(let y=0; y<15; y++) {
        for(let x=0; x<15; x++) {
            if (worldMap[y][x] === 1) { ctx.fillStyle = '#555'; ctx.fillRect(ox+x*s, oy+y*s, s, s); }
            if (worldMap[y][x] === 2) { 
                const hits = wallHitsData[`${y},${x}`] || 0;
                ctx.fillStyle = hits >= 5 ? '#e74c3c' : '#f1c40f'; 
                ctx.fillRect(ox+x*s, oy+y*s, s, s); 
            }
        }
    }
    ctx.fillStyle = 'yellow'; ctx.fillRect(ox+player.x*s-2, oy+player.y*s-2, 4, 4);
    if (monster.x < 100) { ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(ox+monster.x*s, oy+monster.y*s, 3, 0, 7); ctx.fill(); }
}

function triggerQuiz(wx, wy) {
    const overlay = document.getElementById('quiz-overlay');
    if (overlay.style.display === 'flex') return;

    let currentQuiz = null;
    const loadNextQuestion = () => {
        currentQuiz = questionBank[Math.floor(Math.random() * questionBank.length)] || DEFAULT_QUESTIONS[0];
        document.getElementById('q-text').innerText = currentQuiz.q;
        const opts = [currentQuiz.a, ...currentQuiz.b].sort(() => Math.random() - 0.5);
        const container = document.getElementById('q-options');
        container.innerHTML = '';
        
        opts.forEach(o => {
            const btn = document.createElement('button');
            btn.innerText = o;
            btn.onclick = () => handleAnswer(o, currentQuiz.a, wx, wy, loadNextQuestion);
            container.appendChild(btn);
        });
    };

    const card = document.getElementById('quiz-card');
    const msg = document.getElementById('quiz-msg');
    const combo = document.getElementById('monster-combo');

    if (isMonsterQuiz) {
        card.classList.add('monster-mode');
        msg.innerText = "üíÄ GHOST TRAP ACTIVE";
        combo.style.display = 'block';
        combo.innerText = `ÈÄ£Á∫åÊ≠£Á¢∫: ${monsterCombo} / 3`;
    } else {
        card.classList.remove('monster-mode');
        const hits = wallHitsData[`${wy},${wx}`] || 0;
        msg.innerText = `[ TARGET HP: ${Math.max(0, WALL_MAX_HP - hits)} ]`;
        combo.style.display = 'none';
    }

    loadNextQuestion();
    overlay.style.display = 'flex';
}

function handleAnswer(selected, correct, wx, wy, nextFn) {
    const feedback = document.getElementById('feedback-overlay');
    const icon = document.getElementById('feedback-icon');
    const text = document.getElementById('feedback-text');
    const sub = document.getElementById('feedback-sub');
    
    const btns = document.querySelectorAll('#q-options button');
    btns.forEach(b => b.disabled = true);

    const isCorrect = selected === correct;
    
    feedback.style.display = 'flex';
    if (isCorrect) {
        icon.innerText = "‚≠ï"; text.innerText = "Correct!"; text.style.color = "var(--success)"; sub.innerText = "";
        player.personalScore++; // Â¢ûÂä†ÂÄã‰∫∫ÂàÜÊï∏
    } else {
        icon.innerText = "‚ùå"; text.innerText = "Wrong!"; text.style.color = "var(--danger)"; sub.innerText = `Answer: ${correct}`;
    }

    setTimeout(() => {
        feedback.style.display = 'none';
        btns.forEach(b => b.disabled = false);

        if (isMonsterQuiz) {
            if (isCorrect) {
                monsterCombo++;
                document.getElementById('monster-combo').innerText = `ÈÄ£Á∫åÊ≠£Á¢∫: ${monsterCombo} / 3`;
                if (monsterCombo >= 3) {
                    isMonsterQuiz = false;
                    document.getElementById('quiz-overlay').style.display = 'none';
                    monster.cooldownUntil = Date.now() + 10000;
                    showMessage("ÊÄ™Áâ©Ë¢´ÊìäÈÄÄÔºÅÁà≠ÂèñÂà∞ 10 ÁßíÊôÇÈñì", "var(--success)");
                } else { nextFn(); }
            } else {
                monsterCombo = 0; 
                document.getElementById('monster-combo').innerText = `ÈÄ£Á∫åÊ≠£Á¢∫: 0 / 3`;
                nextFn(); 
            }
        } else {
            if (isCorrect) {
                hitWall(wy, wx);
                document.getElementById('quiz-overlay').style.display = 'none';
                showMessage("ÊîªÊìäÊàêÂäüÔºÅÁâÜÂ£ÅÂèóÊêç", "var(--warning)");
            } else {
                document.getElementById('quiz-overlay').style.display = 'none';
                showMessage("ÊîªÊìäÁÑ°Êïà...", "#aaa");
            }
        }
    }, 1500); 
}

window.addEventListener('keydown', e => { if(e.key) keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { if(e.key) keys[e.key.toLowerCase()] = false; });
initSystem();
</script>
</body>
</html>