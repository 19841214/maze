<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vocab Dungeon - Teacher Edition</title>
    <style>
        :root {
            --primary: #007bff;
            --accent: #ff9800;
            --danger: #ff4444;
            --success: #00c853;
            --bg: #f0f2f5;
            --panel: rgba(255, 255, 255, 0.95);
        }
        body { margin: 0; background: var(--bg); color: #333; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; user-select: none; }
        canvas { display: block; }

        /* Start Screen & AI Panel */
        #start-screen {
            position: absolute; inset: 0; background: #dfe6e9; z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow-y: auto; /* Allow scrolling on small screens */
        }
        .config-panel {
            background: white; padding: 30px; border-radius: 15px; width: 90%; max-width: 450px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15); text-align: center; border: 1px solid #fff;
        }
        .title { font-size: 32px; font-weight: 900; color: #2d3436; margin-bottom: 20px; letter-spacing: -1px; }
        
        .group-box {
            border: 2px dashed #b2bec3; padding: 15px; border-radius: 10px; margin-bottom: 20px;
            background: #f8f9fa;
        }
        .group-label { font-size: 14px; font-weight: bold; color: #636e72; margin-bottom: 10px; display: block; text-transform: uppercase; }
        
        .input-field {
            width: 100%; padding: 12px; border: 1px solid #dfe6e9; border-radius: 8px; margin-bottom: 10px;
            font-size: 16px; outline: none; box-sizing: border-box; text-align: center; background: white;
        }
        .input-field:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(0,123,255,0.1); }
        
        .btn-main {
            width: 100%; padding: 15px; background: var(--primary); color: white; border: none;
            border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; transition: 0.2s;
            box-shadow: 0 4px 10px rgba(0,123,255,0.3);
        }
        .btn-main:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0,123,255,0.4); }
        .btn-ai { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
        
        #ai-status { font-size: 13px; color: #00b894; margin-top: 5px; min-height: 20px; }

        /* HUD */
        #hud {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: var(--panel); padding: 12px 15px; border-radius: 10px;
            pointer-events: none; width: 200px; border-left: 5px solid var(--primary);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: none;
        }
        #hud h1 { margin: 0; font-size: 18px; font-weight: 800; color: var(--primary); }
        
        .progress-bar { width: 100%; height: 6px; background: #e0e0e0; margin-top: 5px; border-radius: 3px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: var(--success); transition: width 0.3s; }

        /* Quiz */
        #quiz-overlay {
            position: absolute; inset: 0; background: rgba(255,255,255,0.9); display: none;
            align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(5px);
        }
        .quiz-card {
            background: white; color: #333; width: 90%; max-width: 500px; padding: 30px; border-radius: 20px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.2); border: 1px solid #eee;
        }
        .monster-mode { border: 5px solid var(--danger); background: #fff5f5; }
        .question { font-size: 22px; font-weight: 800; margin-bottom: 25px; line-height: 1.4; }
        .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .opt-btn {
            padding: 15px; background: #f1f2f6; border: 2px solid #dfe4ea; color: #2d3436;
            cursor: pointer; border-radius: 10px; font-size: 16px; font-weight: 700; transition: 0.2s;
        }
        .opt-btn:hover { border-color: var(--primary); background: #e3f2fd; }

        /* Feedback */
        #feedback-overlay { position: absolute; inset: 0; background: rgba(255,255,255,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 20; }
        #feedback-icon { font-size: 80px; margin-bottom: 10px; animation: popIn 0.3s; }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }

        /* Jumpscare */
        #jumpscare { position: fixed; inset: 0; z-index: 3000; background: #000; display: none; align-items: center; justify-content: center; }
        #jumpscare img { width: 100%; height: 100%; object-fit: contain; animation: shake 0.1s infinite; }
        @keyframes shake { 0% { transform: translate(0,0) rotate(0deg); } 25% { transform: translate(5px,5px) rotate(2deg); } 75% { transform: translate(-5px,-5px) rotate(-2deg); } }

        /* Controls & Misc */
        #mobile-controls { position: absolute; bottom: 20px; right: 20px; display: none; flex-direction: column; gap: 10px; align-items: center; z-index: 50; }
        .dpad-row { display: flex; gap: 15px; }
        .dpad-btn { width: 60px; height: 60px; background: rgba(0,0,0,0.1); border: 2px solid rgba(0,0,0,0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #333; font-size: 24px; -webkit-tap-highlight-color: transparent; }
        .dpad-btn:active { background: var(--primary); color: white; }
        @media (max-width: 1024px) { #mobile-controls { display: flex; } }

        #wall-hp-bar { width: 150px; height: 8px; background: #ddd; margin-top: 10px; display: none; border-radius: 4px; overflow: hidden; border: 2px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #wall-hp-fill { width: 0%; height: 100%; background: var(--accent); transition: width 0.1s; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        
        #monster-status { position: absolute; top: 20px; right: 20px; padding: 8px 15px; background: white; border-left: 5px solid var(--danger); color: var(--danger); border-radius: 8px; font-weight: bold; display: none; box-shadow: 0 5px 20px rgba(0,0,0,0.1); }
        #message-box { position: absolute; top: 15%; left: 50%; transform: translateX(-50%); padding: 12px 30px; border-radius: 50px; background: #333; color: white; font-weight: bold; display: none; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        
        #loading { position: fixed; inset: 0; background: #f0f2f5; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #333; font-weight: bold; }
    </style>
</head>
<body>

<img id="scare-img" src="https://i.postimg.cc/4xz0RmTx/1000021389-removebg-preview.png" style="display:none">
<div id="jumpscare"><img src="https://i.postimg.cc/4xz0RmTx/1000021389-removebg-preview.png"></div>

<div id="loading">
    <div style="font-size: 24px; margin-bottom: 10px;">SYSTEM INITIALIZING...</div>
    <div style="font-size: 14px; color:#666;">ËºâÂÖ•Ë≥áÊ∫ê‰∏≠</div>
</div>

<!-- Ë®≠ÂÆöÈù¢Êùø -->
<div id="start-screen" style="display: none;">
    <div class="config-panel">
        <div class="title">VOCAB DUNGEON</div>
        
        <!-- AI Â∞àÂçÄ -->
        <div class="group-box">
            <span class="group-label">ü§ñ AI È°åÂ∫´Êì¥ÂÖÖ (ÈÅ∏Â°´)</span>
            <input type="password" id="api-key-input" class="input-field" placeholder="Ë≤º‰∏ä Gemini API Key">
            <input type="text" id="ai-topic" class="input-field" placeholder="Ëº∏ÂÖ•‰∏ªÈ°å (‰æã: Marvel)">
            <button class="btn-main btn-ai" id="ai-btn" onclick="generateAI()">‚ú® ÁîüÊàê AI È°åÁõÆ</button>
            <div id="ai-status">Ëã•‰∏çËº∏ÂÖ•ÔºåÂ∞á‰ΩøÁî®È†êË®≠ Sheet È°åÂ∫´</div>
        </div>

        <button class="btn-main" onclick="initGame()">üöÄ ÈñãÂßãÈÅäÊà≤ (Start)</button>
    </div>
</div>

<div id="hud">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">ÂñÆ‰∫∫Ê®°Âºè</h1>
    </div>
    <div class="progress-container">
        <div style="display:flex; justify-content:space-between; font-size:12px; margin-top:5px; color:#555; font-weight:bold;">
            <span>ÂæóÂàÜ</span>
            <span id="score">0</span>
        </div>
    </div>
    <p id="goal-info" style="color: var(--accent); margin-top: 5px; font-size: 11px; font-weight:bold;">‚òÖ Á¥ØÁ©ç 50 ÂàÜÈñãÂïüÂÇ≥ÈÄÅÈñÄ</p>
</div>

<div id="monster-status">‚ö† ÊÄ™Áâ©ÈáçÁîü‰∏≠: <span id="cooldown-timer">10</span>s</div>

<div id="crosshair">
    <div style="width: 8px; height: 8px; background: white; border: 2px solid #333; border-radius: 50%;"></div>
    <div id="wall-hp-bar"><div id="wall-hp-fill"></div></div>
    <div id="wall-hp-text" style="margin-top:8px; font-weight:900; font-size:16px; text-shadow:2px 2px 0 rgba(255,255,255,1); display:none; color:var(--accent);"></div>
</div>

<div id="quiz-overlay">
    <div class="quiz-card" id="quiz-card">
        <div id="quiz-msg" style="color: var(--danger); font-weight: 900; margin-bottom: 20px; text-transform:uppercase;">[ ÈéñÂÆö‰∏≠ ]</div>
        <div id="monster-combo" style="display:none; color:var(--danger); margin-bottom:15px; font-weight:bold;">ÈÄÉËÑ´ÈÄ≤Â∫¶: 0/3</div>
        <div class="question" id="q-text">Loading...</div>
        <div class="options-grid" id="q-options"></div>
        <div id="feedback-overlay">
            <div id="feedback-icon"></div>
            <div id="feedback-text" style="font-size:24px; font-weight:bold;"></div>
            <div id="feedback-sub" style="margin-top:10px; font-size:16px; color:#666;"></div>
        </div>
    </div>
</div>

<div id="message-box"></div>

<div id="mobile-controls">
    <div class="dpad-row"><div class="dpad-btn" id="btn-up">‚ñ≤</div></div>
    <div class="dpad-row">
        <div class="dpad-btn" id="btn-left">‚óÄ</div>
        <div class="dpad-btn" id="btn-down">‚ñº</div>
        <div class="dpad-btn" id="btn-right">‚ñ∂</div>
    </div>
</div>

<canvas id="canvas"></canvas>

<script>
// --- Config ---
const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRUrIh3_ELuEAFnI6VRdWWI8AnmkJKh_bplW5PTw3PgQHAyyhXgUZokKOLC0eRcBv9T-XEPti1OlEHI/pub?gid=0&single=true&output=csv";
const MONSTER_IMG = new Image(); 
MONSTER_IMG.src = "https://i.postimg.cc/4xz0RmTx/1000021389-removebg-preview.png";
const AI_MODEL = "gemini-2.5-flash-preview-09-2025";

const AUDIO_SRC = {
    bgm: "https://cdn.pixabay.com/download/audio/2025/12/18/audio_5bf582b607.mp3?filename=delosound-dark-synthwave-retro-80s-453292.mp3",
    breath: "https://cdn.pixabay.com/download/audio/2024/10/04/audio_45f931da37.mp3?filename=hasin2004-breathing-fast-247449.mp3",
    scream: "https://cdn.pixabay.com/download/audio/2022/03/15/audio_3d7d0dcf69.mp3?filename=freesound_community-fuzzy-jumpscare-80560.mp3",
    correct: "https://cdn.pixabay.com/download/audio/2026/01/24/audio_d050f34e8a.mp3?filename=dragon-studio-correct-472358.mp3",
    wrong: "https://cdn.pixabay.com/download/audio/2023/04/23/audio_65f312a7c6.mp3?filename=u_ayf470ljcu-incorrect-buzzer-sound-147336.mp3",
    footstep: "https://cdn.pixabay.com/download/audio/2022/01/18/audio_d948e8b4ec.mp3?filename=freesound_community-metal-footsteps-14727.mp3"
};

const sounds = {};
function loadAudio() {
    for (let k in AUDIO_SRC) {
        sounds[k] = new Audio(AUDIO_SRC[k]);
        if(k === 'bgm' || k === 'breath') sounds[k].loop = true;
    }
    sounds.bgm.volume = 0.2;
    sounds.breath.volume = 0; 
}

// 20x20 Â§ßÂú∞Âúñ
// 1=ËóçÁâÜ, 2=Á¥ÖÈ°åÁâÜ(ÈòªÊìã), 3=ÁµÇÈªû, 0=Ë∑Ø
const worldMap = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,2,1,1,1,0,1,2,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0,0,1],
    [1,1,1,2,1,0,1,1,1,0,1,0,1,1,0,1,1,1,2,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,2,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,2,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1],
    [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,2,1,1,1,1,1,0,1,2,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1],
    [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Game State
const DEFAULT_Q = [{q:"Example: Past tense of 'Go'?", a:"Went", b:["Gone","Going","Goes"]}];
let questions = [];
let wallHits = {}; // { "y,x": hits }
const WALL_HP = 10;

const player = { x: 1.5, y: 1.5, dir: 0, moveSpeed: 0.08, rotSpeed: 0.05, score: 0 };
const monster = { x: 18.5, y: 18.5, speed: 0.02, active: true, cooldown: 0 };
const keys = {};
let isMonsterActive = false, monsterCombo = 0, isGameOver = false;
let lastStepTime = 0;

// --- Init ---
window.onload = function() {
    loadQuestionsFromSheet();
    loadAudio();
}

function loadQuestionsFromSheet() {
    fetch(SHEET_URL).then(r=>r.text()).then(t=>{
        const parsed = t.split(/\r?\n/).slice(1).map(l=>{
            const c = []; let cur='', inQ=false;
            for(let ch of l){ if(ch==='"'){inQ=!inQ} else if(ch===','&&!inQ){c.push(cur.trim());cur=''} else cur+=ch; }
            c.push(cur.trim());
            return c.length>2 ? {q:c[0],a:c[1],b:[c[2],c[3],c[4]]} : null;
        }).filter(x=>x);
        
        if (parsed.length > 0) questions = parsed;
        else questions = DEFAULT_Q;
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
    }).catch(()=>{
        questions = DEFAULT_Q;
        document.getElementById('loading').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
    });
}

// --- AI Generation ---
window.generateAI = async () => {
    const key = document.getElementById('api-key-input').value.trim();
    const topic = document.getElementById('ai-topic').value.trim();
    const status = document.getElementById('ai-status');
    const btn = document.getElementById('ai-btn');

    if(!key) return alert("Ë´ãËº∏ÂÖ• API KeyÔºÅ");
    if(!topic) return alert("Ë´ãËº∏ÂÖ•‰∏ªÈ°åÔºÅ");

    status.innerText = "Gemini Ê≠£Âú®ÊÄùËÄÉ‰∏≠... (Generating)";
    status.style.color = "orange";
    btn.disabled = true;

    const prompt = `Generate 10 multiple choice questions about "${topic}". Return raw JSON: { "questions": [{"q":"Question?", "a":"Correct", "b":["Wrong1","Wrong2","Wrong3"]}] }`;

    try {
        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL}:generateContent?key=${key}`, {
            method: 'POST', headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
        });
        const data = await res.json();
        let text = data.candidates[0].content.parts[0].text;
        text = text.replace(/```json/g, '').replace(/```/g, '').trim();
        const json = JSON.parse(text);
        
        if(json.questions && json.questions.length > 0) {
            questions = json.questions;
            status.innerText = `‚ú® ÊàêÂäüÁîüÊàê ${questions.length} È°åÈóúÊñº "${topic}" ÁöÑÊåëÊà∞ÔºÅ`;
            status.style.color = "green";
        } else throw new Error("Format error");
    } catch(e) {
        console.error(e);
        status.innerText = "ÁîüÊàêÂ§±ÊïóÔºåË´ãÊ™¢Êü• Key ÊàñÁ∂≤Ë∑Ø„ÄÇ";
        status.style.color = "red";
    } finally {
        btn.disabled = false;
    }
};

window.initGame = () => {
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    
    // Spawn
    const spots = [];
    for(let y=1; y<14; y++) for(let x=1; x<14; x++) if(worldMap[y][x]===0 && (x<10||y<10)) spots.push({x:x+0.5, y:y+0.5});
    const s = spots[Math.floor(Math.random()*spots.length)];
    player.x = s.x; player.y = s.y;
    
    sounds.bgm.play();
    sounds.breath.play();
    
    // Controls
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    setupTouchControls();
    
    // Resize
    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    gameLoop();
};

// --- Pathfinding (BFS) ---
function findNextMove(startX, startY, targetX, targetY) {
    const sx = Math.floor(startX), sy = Math.floor(startY);
    const tx = Math.floor(targetX), ty = Math.floor(targetY);
    if (sx === tx && sy === ty) return {x: tx, y: ty};

    const queue = [{x: sx, y: sy, path: []}];
    const visited = new Set();
    visited.add(`${sx},${sy}`);

    while (queue.length > 0) {
        const curr = queue.shift();
        if (curr.x === tx && curr.y === ty) return curr.path[0] || {x: tx, y: ty};

        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        for (let d of dirs) {
            const nx = curr.x + d[0], ny = curr.y + d[1];
            const key = `${nx},${ny}`;
            if (nx >= 0 && nx < 20 && ny >= 0 && ny < 20 && !visited.has(key)) {
                const cell = worldMap[ny][nx];
                // ÊÄ™Áâ©ÊúÉË¢´Á¥ÖÁâÜ (2) Êìã‰ΩèÔºåÈô§ÈùûË¢´ÊâìÁ†¥ (hp<=0)
                const isRedWall = (cell === 2);
                const hp = WALL_HP - (wallHits[`${ny},${nx}`]||0);
                const isBlocked = isRedWall && hp > 0;

                if (!isBlocked && cell !== 1) { // 1ÊòØÁ°¨ÁâÜ
                    visited.add(key);
                    queue.push({x: nx, y: ny, path: [...curr.path, {x: nx, y: ny}]});
                }
            }
        }
    }
    return null;
}

// --- Game Loop ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

function gameLoop() {
    if(isGameOver) return;
    update();
    render();
    requestAnimationFrame(gameLoop);
}

function update() {
    if(document.getElementById('quiz-overlay').style.display === 'flex') return;
    if(document.getElementById('jumpscare').style.display === 'flex') return;

    // Player Move
    const move = keys['w']||keys['arrowup'] ? 1 : (keys['s']||keys['arrowdown'] ? -1 : 0);
    const rot = keys['d']||keys['arrowright'] ? 1 : (keys['a']||keys['arrowleft'] ? -1 : 0);
    
    player.dir += rot * player.rotSpeed;
    const nx = player.x + Math.cos(player.dir) * move * player.moveSpeed;
    const ny = player.y + Math.sin(player.dir) * move * player.moveSpeed;

    if(move !== 0 && Date.now() - lastStepTime > 500) {
        sounds.footstep.currentTime = 0; sounds.footstep.play(); lastStepTime = Date.now();
    }

    // Collision
    const checkWall = (x, y) => {
        const cell = worldMap[Math.floor(y)]?.[Math.floor(x)];
        if(cell === 1) return true;
        if(cell === 2) {
            const hp = WALL_HP - (wallHits[`${Math.floor(y)},${Math.floor(x)}`] || 0);
            if(hp > 0) {
                // Interact range
                triggerQuiz(Math.floor(x), Math.floor(y));
                return true; 
            }
        }
        if(cell === 3) {
            if(player.score >= 50) alert("WIN!");
            else { showMessage("ÈúÄË¶Å 50 ÂàÜÔºÅ", "#f5a623"); player.v = -0.2; return true; }
        }
        return false;
    };

    if(!checkWall(nx, player.y)) player.x = nx;
    if(!checkWall(player.x, ny)) player.y = ny;

    // Monster AI
    if(monster.cooldown > Date.now()) {
        document.getElementById('monster-status').style.display = 'block';
        document.getElementById('cooldown-timer').innerText = Math.ceil((monster.cooldown - Date.now())/1000);
        monster.x = 1000;
    } else {
        document.getElementById('monster-status').style.display = 'none';
        if(monster.x > 100) { monster.x = 18.5; monster.y = 18.5; } // Respawn
        
        const dx = player.x - monster.x, dy = player.y - monster.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // Audio volume by distance
        let vol = 0; if(dist < 10) vol = 1 - (dist / 10);
        sounds.breath.volume = Math.max(0, Math.min(1, vol));

        if(dist < 0.6) {
            monster.active = false;
            sounds.scream.play();
            document.getElementById('jumpscare').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('jumpscare').style.display = 'none';
                monster.x = 18.5; monster.y = 18.5; monster.active = true;
                triggerQuiz(null, null, true); // Penalty
            }, 1500);
        }

        if(monster.active) {
            const nextTile = findNextMove(monster.x, monster.y, player.x, player.y);
            if (nextTile) {
                const tx = nextTile.x + 0.5, ty = nextTile.y + 0.5;
                const mdx = tx - monster.x, mdy = ty - monster.y;
                const md = Math.sqrt(mdx*mdx + mdy*mdy);
                if(md > 0) {
                    monster.x += (mdx/md) * monster.speed;
                    monster.y += (mdy/md) * monster.speed;
                }
            }
        }
    }
}

function render() {
    const w = canvas.width, h = canvas.height;
    
    // Sky/Floor
    const sky = ctx.createLinearGradient(0,0,0,h/2); sky.addColorStop(0,'#87CEEB'); sky.addColorStop(1,'#E0F7FA');
    ctx.fillStyle = sky; ctx.fillRect(0,0,w,h/2);
    const floor = ctx.createLinearGradient(0,h/2,0,h); floor.addColorStop(0,'#9E9E9E'); floor.addColorStop(1,'#424242');
    ctx.fillStyle = floor; ctx.fillRect(0,h/2,w,h/2);

    const zBuffer = new Array(w).fill(0);

    // DDA Raycasting
    for(let x=0; x<w; x++) {
        const camX = 2*x/w - 1;
        const rayDirX = Math.cos(player.dir) + Math.cos(player.dir+1.57)*0.66*camX;
        const rayDirY = Math.sin(player.dir) + Math.sin(player.dir+1.57)*0.66*camX;

        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        let sideDistX, sideDistY, stepX, stepY, hit=0, side=0;
        const deltaDistX = Math.abs(1/rayDirX), deltaDistY = Math.abs(1/rayDirY);

        if(rayDirX<0){stepX=-1;sideDistX=(player.x-mapX)*deltaDistX} else{stepX=1;sideDistX=(mapX+1.0-player.x)*deltaDistX}
        if(rayDirY<0){stepY=-1;sideDistY=(player.y-mapY)*deltaDistY} else{stepY=1;sideDistY=(mapY+1.0-player.y)*deltaDistY}

        while(hit===0) {
            if(sideDistX < sideDistY) { sideDistX+=deltaDistX; mapX+=stepX; side=0; }
            else { sideDistY+=deltaDistY; mapY+=stepY; side=1; }
            
            // Bounds check
            if(mapX<0 || mapX>=20 || mapY<0 || mapY>=20) { hit=1; break; }
            
            const cell = worldMap[mapY][mapX];
            if(cell === 1) hit = 1;
            else if(cell === 2) {
                const hp = WALL_HP - (wallHits[`${mapY},${mapX}`]||0);
                if(hp > 0) hit = 2;
            } else if(cell === 3) hit = 3;
        }

        let perpDist = (side===0) ? (mapX-player.x+(1-stepX)/2)/rayDirX : (mapY-player.y+(1-stepY)/2)/rayDirY;
        zBuffer[x] = perpDist;

        const lh = Math.floor(h/perpDist);
        const start = -lh/2 + h/2;
        
        let color = '#777';
        if(hit===1) color = side===1 ? '#999' : '#aaa'; // Grey Walls
        if(hit===2) color = '#f5a623'; // Orange
        if(hit===3) color = '#00c853'; // Green

        ctx.fillStyle = color; ctx.fillRect(x, start, 1, lh);
    }

    // Sprite
    drawSprite(w, h, zBuffer);
    drawMinimap(w);
}

function drawSprite(w, h, zBuffer) {
    const dx = monster.x - player.x, dy = monster.y - player.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    let angle = Math.atan2(dy, dx) - player.dir;
    while(angle < -Math.PI) angle += Math.PI*2; while(angle > Math.PI) angle -= Math.PI*2;

    if(Math.abs(angle) < 1) { 
        const size = h / dist; 
        const sx = (0.5 * (angle / 0.66) + 0.5) * w; 
        const bufIdx = Math.floor(Math.max(0, Math.min(w-1, sx)));
        if (zBuffer[bufIdx] > dist) { 
            try { ctx.drawImage(MONSTER_IMG, sx - size/2, (h-size)/2, size, size); } catch(e){}
        }
    }
}

function drawMinimap(w) {
    const s = 5, p = 10;
    ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.fillRect(p, p, 20*s, 20*s);
    ctx.strokeStyle = '#333'; ctx.strokeRect(p, p, 20*s, 20*s);
    
    for(let y=0; y<20; y++) {
        for(let x=0; x<20; x++) {
            if(worldMap[y][x]>0) {
                if(worldMap[y][x]===1) ctx.fillStyle='#888';
                else if(worldMap[y][x]===2) {
                    const hp = WALL_HP - (wallHits[`${y},${x}`]||0);
                    ctx.fillStyle = hp>0 ? '#f5a623' : 'rgba(0,0,0,0)';
                }
                else ctx.fillStyle='#0f0';
                ctx.fillRect(p+x*s, p+y*s, s, s);
            }
        }
    }
    ctx.fillStyle = 'blue'; ctx.fillRect(p+player.x*s-2, p+player.y*s-2, 4, 4);
    ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(p+monster.x*s, p+monster.y*s, 3, 0, 6); ctx.fill();
}

function triggerQuiz(x, y, isPenalty = false) {
    const overlay = document.getElementById('quiz-overlay');
    if(overlay.style.display === 'flex') return;
    
    const q = questions[Math.floor(Math.random()*questions.length)] || DEFAULT_Q[0];
    document.getElementById('q-text').innerText = isPenalty ? `[ÊäìÂà∞‰∫Ü!] ${q.q}` : q.q;
    
    const opts = [q.a, ...q.b].sort(()=>Math.random()-0.5);
    const container = document.getElementById('q-options');
    container.innerHTML = '';
    
    if(isMonsterActive) {
        document.getElementById('monster-combo').style.display = 'block';
        document.getElementById('monster-combo').innerText = `ÈÄ£Á∫å: ${monsterCombo}/3`;
        document.querySelector('.quiz-card').classList.add('monster-mode');
    } else {
        document.getElementById('monster-combo').style.display = 'none';
        document.querySelector('.quiz-card').classList.remove('monster-mode');
    }

    opts.forEach(o => {
        const btn = document.createElement('button');
        btn.className = 'opt-btn'; btn.innerText = o;
        btn.onclick = () => answer(o, q.a, x, y, isPenalty);
        container.appendChild(btn);
    });
    
    overlay.style.display = 'flex';
}

function answer(choice, correct, x, y, isPenalty) {
    const overlay = document.getElementById('quiz-overlay');
    const feedback = document.getElementById('feedback-overlay');
    const icon = document.getElementById('feedback-icon');
    const txt = document.getElementById('feedback-text');
    const sub = document.getElementById('feedback-sub');
    
    feedback.style.display = 'flex';
    
    if(choice === correct) {
        sounds.correct.play();
        icon.innerText = "‚≠ï"; txt.innerText = "Á≠îÂ∞ç‰∫Ü"; txt.style.color = "#00c853"; sub.innerText = "";
    } else {
        sounds.wrong.play();
        icon.innerText = "‚ùå"; txt.innerText = "Á≠îÈåØ‰∫Ü"; txt.style.color = "#ff4444"; sub.innerText = `Á≠îÊ°à: ${correct}`;
    }

    setTimeout(() => {
        feedback.style.display = 'none';
        if(isMonsterActive) {
            if(choice === correct) {
                monsterCombo++;
                if(monsterCombo >= 3) {
                    isMonsterActive = false; overlay.style.display = 'none';
                    monster.cooldown = Date.now() + 10000; showMessage("ÊàêÂäüÈÄÉËÑ´ÔºÅ", "green");
                } else triggerQuiz(null, null, true);
            } else { monsterCombo = 0; triggerQuiz(null, null, true); }
        } else {
            if(choice === correct) {
                wallHits[`${y},${x}`] = (wallHits[`${y},${x}`]||0) + 1;
                player.score += 10;
                document.getElementById('score').innerText = player.score;
                overlay.style.display = 'none';
                
                const hp = WALL_HP - (wallHits[`${y},${x}`]||0);
                if(hp > 0) showMessage(`ÁâÜÂ£ÅÂèóÊêç! Ââ©È§ò HP: ${hp}`, "orange");
                else showMessage("ÁâÜÂ£ÅÁ†¥Â£ûÊàêÂäü!", "green");
            } else {
                overlay.style.display = 'none';
                showMessage("ÊîªÊìäÁÑ°Êïà...", "red");
            }
        }
    }, 1500);
}

function showMessage(txt, color) {
    const box = document.getElementById('message-box');
    box.innerText = txt; box.style.borderColor = color; box.style.color = color;
    box.style.display = 'block';
    setTimeout(()=>box.style.display='none', 2000);
}

function setupTouchControls() {
    const bind = (id, key) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e)=>{e.preventDefault(); keys[key]=true;});
        el.addEventListener('touchend', (e)=>{e.preventDefault(); keys[key]=false;});
    };
    bind('btn-up', 'arrowup'); bind('btn-down', 'arrowdown');
    bind('btn-left', 'arrowleft'); bind('btn-right', 'arrowright');
}
</script>
</body>
</html>